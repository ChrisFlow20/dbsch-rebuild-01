CREATE TABLE TEST (
    TEST_NAME CHAR(30) NOT NULL,
    TEST_ID INTEGER DEFAULT '0' NOT NULL,
    TEST_DATE TIMESTAMP NOT NULL
);
ALTER TABLE TEST ADD CONSTRAINT PK_TEST PRIMARY KEY (TEST_ID);

COMMENT ON COLUMN test.test_name IS 'This is the name of the test';
-- TABLE TEST2 with some CONSTRAINTs and an INDEX
CREATE TABLE TEST2 (
    ID INTEGER NOT NULL,
    FIELD1 INTEGER,
    FIELD2 CHAR(15),
    FIELD3 VARCHAR(50),
    FIELD4 INTEGER,
    FIELD5 INTEGER,
    ID2 INTEGER NOT NULL
);
ALTER TABLE TEST2 ADD CONSTRAINT PK_TEST2 PRIMARY KEY (ID2);
ALTER TABLE TEST2 ADD CONSTRAINT TEST2_FIELD1ID_IDX UNIQUE (ID, FIELD1);
ALTER TABLE TEST2 ADD CONSTRAINT TEST2_FIELD4_IDX UNIQUE (FIELD4);
CREATE INDEX TEST2_FIELD5_IDX ON TEST2(FIELD5);

CREATE TABLE NUMBERS (
    NUMBER INTEGER DEFAULT '0' NOT NULL,
    EN CHAR(100) NOT NULL,
    FR CHAR(100) NOT NULL
);


CREATE TABLE NEWTABLE (
    ID INT DEFAULT 0 NOT NULL,
    SOMENAME VARCHAR (12),
    SOMEDATE TIMESTAMP NOT NULL
);

ALTER TABLE NEWTABLE ADD CONSTRAINT PKINDEX_IDX PRIMARY KEY (ID);
CREATE SEQUENCE NEWTABLE_SEQ INCREMENT 1 START 1;

CREATE VIEW "testview"( TEST_NAME,TEST_ID,TEST_DATE) AS SELECT * FROM TEST WHERE TEST_NAME LIKE 't%';

CREATE VIEW "numbersview"( NUMBER, TRANS_EN, TRANS_FR ) AS SELECT * FROM NUMBERS WHERE NUMBER > 100;

CREATE FUNCTION add_stamp() RETURNS OPAQUE AS '
BEGIN
    IF (NEW.somedate IS NULL OR NEW.somedate = 0) THEN
    NEW.somedate := CURRENT_TIMESTAMP;
    RETURN NEW;
    END IF;
END;
' LANGUAGE 'plpgsql';

CREATE TRIGGER ADDCURRENTDATE
    BEFORE INSERT OR UPDATE
    ON newtable FOR EACH ROW
    EXECUTE PROCEDURE add_stamp();

CREATE TABLE testconstraints (
    someid integer NOT NULL,
    somename character varying(10) NOT NULL,
    CONSTRAINT testconstraints_id_pk PRIMARY KEY (someid)
);

CREATE TABLE testconstraints2 (
    ext_id integer NOT NULL,
    modified date,
    uniquefield character varying(10) NOT NULL,
    usraction integer NOT NULL,
    CONSTRAINT testconstraints_id_fk FOREIGN KEY (ext_id)
    REFERENCES testconstraints (someid) MATCH SIMPLE
    ON UPDATE CASCADE ON DELETE CASCADE,
    CONSTRAINT unique_2_fields_idx UNIQUE (modified, usraction),
    CONSTRAINT uniquefld_idx UNIQUE (uniquefield)
);
